## 데이터베이스 인덱스(Index)

데이터베이스 인덱스는 데이터베이스 테이블의 특정 컬럼(또는 컬럼 집합)에 대한 빠른 데이터 검색을 돕기 위해 사용되는 특수한 데이터 구조입니다. 마치 책의 색인(Index)과 같이, 원하는 데이터를 빠르게 찾을 수 있도록 돕는 역할을 합니다. 인덱스는 일반적으로 B-트리(B-Tree)나 B+트리(B+Tree)와 같은 자료구조로 구현되어 데이터의 물리적 위치를 효율적으로 탐색할 수 있게 합니다.

### 1. 인덱스의 개념 및 필요성

**개념:** 인덱스는 테이블의 행(Row)을 검색하는 데 사용되는 주소 목록입니다. 특정 컬럼의 값을 기반으로 데이터가 저장된 물리적 위치를 가리키므로, 테이블 전체를 스캔(Full Table Scan)하지 않고도 데이터를 빠르게 찾아낼 수 있습니다.

**필요성:**

- **검색 속도 향상:** `SELECT` 문을 이용한 데이터 조회 시, 원하는 데이터를 빠르게 찾을 수 있도록 하여 쿼리 성능을 크게 향상시킵니다. 특히 대량의 데이터에서 특정 조건을 만족하는 데이터를 찾을 때 효과적입니다.
    
- **정렬 및 그룹화 작업 효율 증대:** `ORDER BY`나 `GROUP BY`와 같이 데이터를 정렬하거나 그룹화하는 작업에서 인덱스를 활용하면 별도의 정렬 과정을 거치지 않아도 되어 성능이 향상됩니다.
    
- **데이터 무결성 유지(Unique Index):** 고유 인덱스(Unique Index)를 설정하면 특정 컬럼의 값이 중복되지 않도록 강제하여 데이터의 유일성을 보장하고 무결성을 유지할 수 있습니다.
    
- **조인(Join) 성능 향상:** 여러 테이블을 조인할 때, 조인 조건으로 사용되는 컬럼에 인덱스가 있다면 조인 작업의 효율성이 증대됩니다.
    

**단점:**

- **저장 공간 추가 사용:** 인덱스도 별도의 저장 공간을 차지하므로, 테이블의 크기가 커질수록 인덱스가 차지하는 공간도 늘어납니다.
    
- **데이터 변경 작업(DML) 성능 저하:** `INSERT`, `UPDATE`, `DELETE`와 같은 데이터 변경 작업이 발생하면, 테이블의 데이터뿐만 아니라 인덱스도 함께 업데이트해야 하므로 성능 저하가 발생할 수 있습니다.
    
- **인덱스 관리 오버헤드:** 과도한 인덱스 생성은 오히려 성능을 저하시킬 수 있으며, 인덱스 관리에 추가적인 리소스가 필요합니다.
    

### 2. 클러스터드 인덱스(Clustered Index)

클러스터드 인덱스는 테이블의 **물리적인 저장 순서**를 인덱스의 순서와 일치시키는 인덱스입니다. 테이블당 **하나만 생성**할 수 있으며, 인덱스 자체가 데이터 레코드를 포함합니다.

- **정의:** 테이블의 기본 키(Primary Key)에 의해 자동으로 생성되는 경우가 많으며(RDBMS 종류에 따라 다름), 테이블의 실제 데이터가 인덱스의 정렬 순서에 따라 물리적으로 저장됩니다.
    
- **특징:**
    
    - **물리적 순서 정렬:** 테이블의 데이터 레코드가 인덱스 키 값에 따라 물리적으로 정렬되어 저장됩니다.
        
    - **테이블당 하나만 존재:** 데이터의 물리적 저장 순서는 하나밖에 있을 수 없으므로, 클러스터드 인덱스는 테이블당 하나만 생성할 수 있습니다.
        
    - **데이터 포함:** 인덱스의 리프(Leaf) 노드가 실제 데이터 레코드(테이블 전체 행)를 직접 포함하고 있습니다.
        
    - **빠른 범위 검색:** 물리적으로 인접해 있으므로 범위 검색(Range Scan)에 매우 효율적입니다.
        
    - **단점:** 데이터 삽입/삭제 시 물리적인 재정렬이 발생할 수 있어 오버헤드가 크고, 인덱스가 없는 컬럼으로 검색 시에는 테이블 스캔이 발생할 수 있습니다.
        
- **활용 예시:** 고객 테이블에서 `고객ID`를 클러스터드 인덱스로 설정하면, 실제 고객 데이터가 `고객ID` 순서로 물리적으로 저장됩니다.
    

### 3. 논클러스터드 인덱스(Non-Clustered Index)

논클러스터드 인덱스는 테이블의 물리적 저장 순서와는 **독립적으로 생성**되는 인덱스입니다. 테이블당 **여러 개 생성**할 수 있으며, 인덱스 리프 노드는 데이터의 실제 위치(클러스터드 인덱스의 키 값 또는 물리적 주소)를 가리킵니다.

- **정의:** 클러스터드 인덱스와 달리, 데이터의 물리적 저장 순서를 변경하지 않고 논리적인 정렬 순서만을 가집니다. 인덱스 자체는 키 값과 해당 데이터 레코드를 가리키는 포인터(또는 클러스터드 인덱스의 키 값)로 구성됩니다.
    
- **특징:**
    
    - **독립적인 저장:** 인덱스 자체는 별도의 저장 공간에 저장되며, 테이블의 데이터는 물리적 순서와 무관하게 저장됩니다.
        
    - **테이블당 여러 개 생성 가능:** 여러 컬럼에 대해 여러 개의 논클러스터드 인덱스를 생성할 수 있습니다.
        
    - **포인터 포함:** 인덱스의 리프 노드가 실제 데이터 레코드가 저장된 위치(ROWID 또는 클러스터드 인덱스의 키 값)를 가리킵니다. 데이터를 찾기 위해서는 인덱스를 통해 포인터를 얻은 후, 해당 포인터로 실제 데이터를 다시 찾아가는 과정(책갈피를 찾아가는 과정과 유사)이 필요합니다.
        
    - **넓은 활용성:** 특정 컬럼에 대한 빠른 검색을 위해 다양하게 활용될 수 있습니다.
        
    - **단점:** 클러스터드 인덱스에 비해 검색에 한 단계 더 많은 과정을 거치므로 단일 레코드 조회 시 상대적으로 느릴 수 있습니다 (조회 결과가 인덱스에 포함된 컬럼으로만 구성될 때는 빠름). `INSERT`, `UPDATE`, `DELETE` 시에도 인덱스 업데이트 오버헤드가 발생합니다.
        
- **활용 예시:** 고객 테이블에서 `고객명`이나 `주소` 컬럼에 논클러스터드 인덱스를 설정하면, `고객명`이나 `주소`를 기준으로 빠르게 검색할 수 있습니다.
    

### 4. 클러스터드 인덱스와 논클러스터드 인덱스 비교

|구분|클러스터드 인덱스(Clustered Index)|논클러스터드 인덱스(Non-Clustered Index)|
|---|---|---|
|**물리적 데이터 순서**|인덱스 순서와 **동일** (데이터 자체가 정렬됨)|인덱스 순서와 **무관** (데이터는 원래 위치)|
|**생성 개수**|테이블당 **단 하나**만 가능|테이블당 **여러 개** 생성 가능|
|**리프 노드 내용**|**실제 데이터 레코드** 전체|데이터 레코드를 가리키는 **포인터** (ROWID 또는 클러스터드 키)|
|**데이터 접근**|인덱스 탐색 후 바로 데이터 접근|인덱스 탐색 후 포인터를 통해 데이터 재접근 (2단계)|
|**주요 장점**|범위 검색 및 정렬에 매우 효율적|다양한 컬럼에 대해 유연하게 검색 속도 향상|
|**주요 단점**|삽입/삭제 시 물리적 재정렬 오버헤드, 하나만 가능|데이터 접근에 한 단계 추가, 인덱스 추가 공간 소요|
|**적합한 경우**|기본 키(Primary Key) 또는 범위 검색이 잦은 컬럼|특정 컬럼으로의 조회나 정렬이 잦은 컬럼|

적절한 인덱스 전략 수립은 데이터베이스 성능 최적화의 핵심입니다. 클러스터드 인덱스와 논클러스터드 인덱스의 특성을 이해하고, 쿼리 패턴과 데이터 특성에 맞춰 적절히 활용하는 것이 중요합니다.

**요약**: 데이터베이스 인덱스는 빠른 데이터 검색을 위한 특수 자료구조입니다. 클러스터드 인덱스는 데이터의 물리적 저장 순서를 인덱스 순서와 일치시키며 테이블당 하나만 가능하고 리프 노드가 실제 데이터를 포함합니다. 논클러스터드 인덱스는 물리적 순서와 독립적이며 여러 개 생성 가능하고 리프 노드가 데이터 위치를 가리키는 포인터를 포함합니다.