## 인터넷 통신 보안 프로토콜: TLS 1.2와 TLS 1.3

인터넷 통신의 보안성 강화를 위해 널리 사용되는 TLS(Transport Layer Security)는 웹 브라우징, 이메일, VoIP 등 다양한 애플리케이션에서 데이터의 기밀성, 무결성, 신뢰성을 보장합니다. 최근에는 TLS 1.2의 취약점들이 발견됨에 따라 TLS 1.3으로의 전환이 강력히 권고되고 있습니다.

### 가. TLS 프로토콜 구조와 핸드셰이크(Handshake) 과정

TLS는 OSI 7계층 모델의 전송 계층(Transport Layer) 위, 응용 계층(Application Layer) 아래에서 동작하는 프로토콜입니다. 주로 TCP 위에서 동작하여 응용 계층 데이터의 암호화 및 보안을 담당합니다.

**1. TLS 프로토콜 구조**

TLS는 크게 두 개의 주요 서브 프로토콜로 구성됩니다.

- **TLS Handshake Protocol (핸드셰이크 프로토콜)**:
    
    - 클라이언트와 서버 간에 암호화 통신을 시작하기 전에 필요한 보안 파라미터(암호화 스위트, 키 교환 방식, 압축 방식 등)를 협상하고, 서로를 인증하며, 세션 키를 생성하는 과정을 담당합니다.
        
    - 이 프로토콜을 통해 안전한 채널을 설정한 후에 실제 데이터 통신이 이루어집니다.
        
    - 주로 Handshake, Change Cipher Spec, Alert Protocol로 구성됩니다.
        
- **TLS Record Protocol (레코드 프로토콜)**:
    
    - 핸드셰이크 프로토콜에 의해 설정된 보안 파라미터(세션 키 등)를 사용하여 실제 애플리케이션 데이터를 암호화, 무결성 보호(MAC 추가), 압축하고 전송하는 역할을 합니다.
        
    - 수신된 데이터에 대해서는 역으로 복호화, 무결성 검증, 압축 해제 과정을 수행하여 응용 계층에 전달합니다.
        
    - 레코드 프로토콜은 핸드셰이크가 완료된 후 모든 응용 데이터 통신에 사용됩니다.
        

**2. TLS 핸드셰이크(Handshake) 과정**

TLS 핸드셰이크는 클라이언트와 서버가 안전한 통신을 위한 약속(세션 키, 암호화 방식 등)을 설정하는 과정입니다. TLS 1.2를 기준으로 하는 일반적인 핸드셰이크 과정은 다음과 같습니다.

1. **Client Hello**: 클라이언트가 서버에게 TLS 통신을 시작하자는 메시지를 보냅니다. 이 메시지에는 클라이언트가 지원하는 TLS 버전, 암호화 스위트 목록(Cipher Suites), 압축 방식, 클라이언트가 생성한 난수(Client Random) 등이 포함됩니다.
    
2. **Server Hello**: 서버는 클라이언트의 Client Hello 메시지를 받고, 자신이 지원하는 TLS 버전, 클라이언트가 제시한 암호화 스위트 중 하나, 압축 방식, 서버가 생성한 난수(Server Random) 등을 선택하여 응답합니다.
    
3. **Certificate**: 서버는 자신의 디지털 인증서(서버의 공개 키와 신원 정보 포함)를 클라이언트에게 보냅니다. 경우에 따라 클라이언트 인증서 요청(Client Certificate Request)을 보낼 수도 있습니다.
    
4. **Server Key Exchange (옵션)**: Diffie-Hellman과 같은 키 교환 방식을 사용하는 경우, 서버는 이 메시지를 통해 키 교환에 필요한 파라미터를 전송합니다.
    
5. **Server Hello Done**: 서버가 핸드셰이크 메시지 전송을 마쳤음을 클라이언트에게 알립니다.
    
6. **Client Key Exchange**: 클라이언트는 서버의 인증서(및 키 교환 파라미터)를 검증하고, 서버의 공개 키를 사용하여 대칭키 생성에 사용될 **Pre-Master Secret**를 암호화하여 서버에게 전송합니다.
    
7. **Change Cipher Spec**: 클라이언트가 이제부터 방금 협상된 암호화 파라미터와 생성된 세션 키를 사용하여 통신할 것임을 서버에 알립니다.
    
8. **Finished (Client)**: 클라이언트가 지금까지 주고받은 핸드셰이크 메시지들의 해시 값(MAC)을 암호화하여 전송합니다. 서버는 이를 통해 핸드셰이크 과정이 변조되지 않았음을 확인합니다.
    
9. **Change Cipher Spec (Server)**: 서버도 이제부터 암호화된 통신을 시작할 것임을 클라이언트에 알립니다.
    
10. **Finished (Server)**: 서버도 지금까지의 핸드셰이크 메시지 해시 값을 암호화하여 전송합니다. 클라이언트는 이를 검증하여 핸드셰이크 완료를 확인합니다.
    

이 과정이 성공적으로 완료되면, 클라이언트와 서버는 서로 합의된 세션 키를 사용하여 암호화된 안전한 통신 채널을 통해 애플리케이션 데이터를 주고받기 시작합니다.

### 나. TLS 1.2 보안 취약점과 TLS 1.3 개선 사항

TLS 1.2는 오랫동안 널리 사용되어 왔지만, 시간이 지남에 따라 여러 가지 보안 취약점이 발견되었습니다. TLS 1.3은 이러한 취약점들을 해결하고 성능을 개선하기 위해 설계되었습니다.

**1. TLS 1.2의 주요 보안 취약점**

- **다양한 암호화 스위트 지원 (Too Many Options)**: TLS 1.2는 다양한 암호화 스위트와 키 교환 방식을 지원합니다. 이로 인해 과거의 취약한 암호화 알고리즘(예: RC4, MD5, SHA-1 기반 해시)이 여전히 허용될 수 있어, 서버 또는 클라이언트의 설정 미숙으로 인해 공격에 노출될 위험이 있었습니다.
    
    - **SWEET32 (Birthday Attack)**: 블록 암호의 블록 크기가 작은(예: 64비트) 암호화 알고리즘(3DES, Blowfish) 사용 시, 대량의 데이터를 전송하면 충돌 공격(Collision Attack)에 취약해지는 문제.
        
    - **BEAST, CRIME, BREACH 공격**: 특정 압축 방식이나 CBC(Cipher Block Chaining) 모드 사용 시 발생하는 취약점으로, 평문 데이터를 복구하거나 민감 정보를 유출할 수 있었습니다.
        
- **복잡하고 느린 핸드셰이크 과정**: 위에서 설명된 복잡한 핸드셰이크 과정은 여러 번의 왕복(Round Trip Time, RTT)을 필요로 하여 초기 연결 설정 지연(Latency)을 유발했습니다. 이는 특히 모바일 환경에서 성능 저하의 원인이 됩니다.
    
- **전방향 비밀성(Forward Secrecy) 미강화**: 일부 키 교환 방식(예: RSA 기반 키 교환)은 서버의 개인 키가 유출될 경우 과거 통신 내용까지 모두 복호화될 수 있는 전방향 비밀성 문제가 있었습니다. Diffie-Hellman 계열을 강제하지 않아 설정에 따라 취약할 수 있었습니다.
    
- **재협상(Renegotiation) 공격**: TLS 세션을 재협상하는 과정에서 서비스 거부(DoS) 공격이나 중간자 공격(Man-in-the-Middle)에 취약점이 발견되었습니다.
    

**2. TLS 1.3의 주요 개선 사항**

TLS 1.3은 보안 강화와 성능 개선에 중점을 두고 설계되었습니다.

- **불필요하고 취약한 암호화 스위트 제거**: TLS 1.3은 과거에 사용되던 취약한 암호화 알고리즘(예: RC4, SHA-1, MD5 등) 및 비안전한 키 교환 방식을 **강제로 제거**하고, 안전성이 검증된 알고리즘(예: AEAD 모드를 사용하는 AES-GCM, ChaCha20-Poly1305)만 사용하도록 제한합니다. 또한, 전방향 비밀성을 보장하는 Diffie-Hellman (DHE 또는 ECDHE) 기반의 키 교환 방식만을 허용합니다.
    
- **핸드셰이크 과정 간소화 및 성능 향상**:
    
    - **0-RTT(Zero Round Trip Time) 지원**: 한 번 연결했던 서버에 재접속할 때 이전 세션 정보를 활용하여 암호화된 데이터를 첫 요청과 함께 전송할 수 있게 되어, 연결 설정 시간을 0-RTT로 단축시킵니다.
        
    - **1-RTT 핸드셰이크**: 기존 TLS 1.2의 2-RTT 핸드셰이크를 1-RTT로 단축시켰습니다. 클라이언트가 `Client Hello` 메시지에 자신이 예측하는 키 교환 정보와 함께 암호화된 데이터를 미리 보내는 `Early Data` 기능을 포함할 수 있습니다.
        
- **전방향 비밀성(Forward Secrecy) 강화**: 모든 키 교환 방식에 Perfect Forward Secrecy(PFS)를 의무적으로 적용하여, 현재 세션 키가 노출되더라도 과거 또는 미래의 세션 키를 유추할 수 없도록 합니다. 이는 서버의 장기 개인 키가 노출되어도 과거 통신 내용을 복호화할 수 없게 만듭니다.
    
- **재협상(Renegotiation) 기능 제거 및 간소화**: 재협상 관련 보안 취약점을 제거하기 위해, 명시적인 재협상 기능을 제거하고 새롭게 정의된 방식으로 세션 재개를 처리합니다.
    
- **암호화 범위 확장**: 핸드셰이크 과정의 상당 부분을 암호화하여 통신 시작 단계에서의 메타데이터 노출 위험을 줄였습니다.
    

TLS 1.3은 더 강력한 보안 기능과 향상된 성능을 제공함으로써 현대 인터넷 환경의 보안 요구사항을 충족시키는 데 필수적인 프로토콜로 자리매김하고 있습니다. 이에 따라 많은 웹 서비스와 애플리케이션들이 TLS 1.3으로의 업그레이드를 적극적으로 추진하고 있습니다.

**요약**: TLS는 인터넷 통신의 기밀성, 무결성, 신뢰성을 보장하는 프로토콜입니다. TLS 1.2는 다양한 암호화 스위트의 취약성과 복잡한 핸드셰이크 과정이 문제였으나, TLS 1.3은 취약한 알고리즘을 제거하고 핸드셰이크를 간소화(1-RTT, 0-RTT)하며 전방향 비밀성을 강화하여 보안과 성능을 크게 개선했습니다.